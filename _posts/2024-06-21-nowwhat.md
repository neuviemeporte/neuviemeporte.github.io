---
layout: post
title: Now what?
date: 2024-06-21
category: f15-se2
---

<small>(_This post is part of a [series]({% link category/f15-se2.html %}) on the subject of my hobby project, which is recreating the C source code for the 1989 game [F-15 Strike Eagle II]({% post_url 2022-06-05-origins %}) by reverse engineering the original binaries._)</small>

Recently, I've been on a roll, completing one routine after another. Then suddenly, after fixing the last problem in a medium-sized routine I was working on, I was presented this output from `make verify`, the Makefile target which builds the reconstructed executable and runs `mzdiff` to compare it to the original:

<pre>
[...]
1000:3b7f/013b7f: jmp 0x3a90 (0xf2 up)             == 1000:27a1/0127a1: jmp 0x26b2 (0xf2 up)
1000:3b82/013b82: jmp short 0x3b84 (0x0 down)      == 1000:27a4/0127a4: jmp short 0x27a6 (0x0 down)
1000:3b84/013b84: pop si                           == 1000:27a6/0127a6: pop si
1000:3b85/013b85: mov sp, bp                       == 1000:27a7/0127a7: mov sp, bp
1000:3b87/013b87: pop bp                           == 1000:27a9/0127a9: pop bp
1000:3b88/013b88: ret                              == 1000:27aa/0127aa: ret
Reached end of routine block @ 1000:3b88/013b88
Completed comparison of routine sub_13A61, no more reachable blocks
<g>Comparison result: match</g>
Load module of executable is 45270/0xb0d6 bytes
Routine map of 241 routines covers 27352/0x6ad8 bytes (60% of the load module)
Reachable code totals 23929/0x5d79 bytes (87% of the mapped area)
Unreachable code totals 3579/0xdfb bytes (13% of the mapped area)
Excluded 155 routines totaling 11803/0x2e1b bytes (43% of the mapped area)
Compared 15419/0x3c3b bytes of opcodes (64% of the reachable area)
Seen 138 routines, ignored (seen but excluded) 68 routines totaling 3258/0xcba bytes (11% of the mapped area)
Excluded routines take 8434/0x20f2 bytes (35% of the reachable area)
Total coverage (seen + excluded) is 23853/0x5d2d (<g>99%</g> of the reachable area)
Missed (not seen and not excluded) 16 routines totaling 76/0x4c bytes (<r>0%</r> of the covered area)
1000:3586-1000:3586/000001: nullsub_1 [near]
16b5:0af9-16b5:0afd/000005: routine_41 [far]
16b5:0b03-16b5:0b07/000005: routine_47 [far]
16b5:0b08-16b5:0b0c/000005: routine_40 [far]
16b5:0b53-16b5:0b57/000005: routine_129 [far]
16b5:0b58-16b5:0b5c/000005: routine_42 [far]
16b5:0b62-16b5:0b66/000005: routine_45 [far]
16b5:0b80-16b5:0b84/000005: routine_44 [far]
16b5:0bb7-16b5:0bbb/000005: routine_61 [far]
16b5:0bbc-16b5:0bc0/000005: routine_70 [far]
16b5:0bc1-16b5:0bc5/000005: routine_62 [far]
16b5:0bc6-16b5:0bca/000005: routine_71 [far]
16b5:0bd0-16b5:0bd4/000005: routine_57 [far]
16b5:0bda-16b5:0bde/000005: routine_59 [far]
16b5:0bdf-16b5:0be3/000005: routine_58 [far]
16b5:0c4d-16b5:0c51/000005: routine_46 [far]
</pre>

So... that's it? We're done (with the first executable of 3)? Well, the answer is not that simple. TL;DR: not really.

But it's a milestone nonetheless, and to celebrate, I've decided to [release the code](https://github.com/neuviemeporte/f15se2-re) that I have written up till now. So, enjoy.

Now the thing I wish to address is the completion metrics, and what they actually mean. I have a bunch of those on my tooling, so let's discuss them starting from the top.
 
# Completion according to lst2ch.py

When I make a change in the IDA database, I have it export the listing (`.lst`) file, which triggers a recreation of the autogenerated C header file using the Python script `lst2ch.py`. That script walks over the listing and gathers a bunch of information, which it prints out before terminating:

```
tools/lst2ch.py lst/start.lst src/f15-se2 conf/start_rc.json --noc
Found matching include file: lst/start.inc, parsing
Writing C header file: src/f15-se2/start.h
Found routines: total: 247, ignored: 53, remaining: 194, ported: 68, need porting: 126
Accumulated routines' size: remaining: 21638/0x5486/100%, ported: 15424/0x3c40/71.28%, need porting: 6214/0x1846/28.72%
Found 985 variables, size = 31504/0x7b10
```

Because this tool walks the IDA listing, it has a more completionist view of all the routines, which is why it can see 247 of those. The ignored ones are pretty much the libc routines which were marked by IDA based on signature comparison, but the tool counts routines as ignored based on the fact that their names in the listing begin with an underscore or equal 'start' (the CRT0 stuff). Yeah, not perfect, might have some issues there.

Next, it takes the remaining routines (all of them minus the ignored ones), sums up their extents (chunks, i.e. detached bits of code that belong to a routine are not covered -- yeah we have those as well), and that is our baseline 100% completion. Then it goes over the list of extracted areas, which are address ranges marked for snipping out of the listing, presumably because they are/will be replaced with C code, and that counts as the "ported" amount. The remainder is obvious, these are the routines which have not been ported yet, either because I didn't get to them, or they were originally written in assembly and are not suitable for per-instruction recreation.

Makes sense so far? The percentages are particularly deceiving because it depends where your baseline is, and this tool sets that at the cutoff level of the ignored routines, with the disctinction being kinda flaky. In any case, I seem to have about 70% of the relevant code ported to C at this point.

# Completion according to mzdiff

Next, the game executable gets built from the reconstructed source + the assembly containing everything not reconstructed yet which is autogenerated from the complete listing by `lst2asm.py`, and it gets compared to the original with `mzdiff` to form the output I opened this post with. 

Here, the line gets blurrier. The comparison tool does not base its operation on the IDA listing, but the map file that originally came from `mzmap`, and was tweaked manually thereafter to more or less correspond to the layout seen by IDA, but the results are not identical due to the way chunks are handled.

Also, mzdiff starts off from an entrypoint in both executables, and walks the opcodes in both, comparing them and storing calls and jumps in a DFS search queue. Because it does not know the layout of the reconstructed binary (the mapfile describes the original), it does not know and cannot assume where an equivalent routine resides for comparison - it has to scrape that info from watching for calls and jumps. The result is that it cannot compare what it cannot reach, and it cannot reach what cannot be determined from static analysis. So far, I haven't had any problems with it, but it does say that reachable code was only 87% of the area covered by the map - all the rest will need to be carefully investigated to figure out if it's really unreachable, or just the tool can't see how control gets there - and develop capabilities to instruct it in that regard. But for what it's worth, IDA also shows them as unreachable, so might be the executable just contains a bunch of leftover garbage.

It also counts more routines than before (155) as excluded - in addition to the libc routines, the mapfile instructs the tool to ignore additional routines, typically ones which appear to be assembly. In general, the tool supports the following annotations on mapfile routine specifications:

* `ignore`: don't go inside to compare instructions, it will not be possible to create identical equivalents
* `complete`: this routine has been completely reconstructed into identical C code
* `external`: routine from an external library, i.e. libc. This implies `ignore`.
* `detached`: routine that appears unreachable. This also implies `ignore`.

That means the tool only performed the comparison on 64% of the reachable area, which as you remember is in turn only 87% of the greater mapped area. Based on my current knowledge however, there does not appear to be a way or need to go any deeper, for now at least. The good news is that the tool seems to have covered 99% of the reachable area, either through the comparison, or because they were excluded for whatever reason (libc, detached chunk, or ignored assembly routine). The remainder is called "missed" and takes only 76 bytes - those are mostly [far jumps]({% post_url 2023-03-23-farcalls %}) into [driver overlays]({% post_url 2023-07-12-overlays %}) that I need to set as ignored, plus a single case of an assembly routine whose bounds collide with another, that I have not sorted out yet.

See, I told you the percentages would get confusing. Just how much stuff is there actually left to do?

# Completion according to mzmap

If you have two sets of statistics which don't make your view of a problem any clearer, surely the answer is to implement a third set of statistics in another tool, isn't it? I wish I was joking.

The problem was that mzdiff is really not designed to gather and present this information -- it's goal is to compare instructions. Also, until a few days ago, I did not have the routine annotations `external`/`detached` implemented, so all the `ignore`d routines were all thrown into one bag, making it difficult to see which ignored routines were part of libc and really didn't need to get touched, which ones were part of the game but seemed unreachable so there didn't seem to be a point reconstructing them, and which were not included in the comparison because of being written in assembly, but would need porting work at some point. 

So I ended up extending `mzmap` to also print out the contents of the mapfile in detail, implemented the extra annotations, and went over the IDA listing to update the contents of the mapfile: figure out what routines were missing from the map, which ones could be considered `detached`, that sort of thing. The result is as follows:

```
ninja@RYZEN:eaglestrike$ mzretools/debug/mzmap map/start.map  --hide
--- Routine map containing 241 routines
Size 45270/0xb0d6
Code1 CODE 0000
Code2 CODE 06a5
Data1 DATA 06b5
Stack1 STACK 0e66
0000:32d6-0000:3311/00003c: unclaimed_9 [near] [unclaimed]
0000:5e68-0000:5e6d/000006: unclaimed_22 [near] [unclaimed]
0000:5ee4-0000:5f09/000026: unclaimed_23 [near] [unclaimed]
0000:6500-0000:6541/000042: unclaimed_27 [near] [unclaimed]
0000:67ed-0000:6838/00004c: unclaimed_29 [near] [unclaimed]
06a5:000c-06a5:002e/000023: unclaimed_31 [near] [unclaimed]
06a5:00cb-06a5:00de/000014: unclaimed_32 [near] [unclaimed]
06a5:00f7-06a5:00ff/000009: unclaimed_33 [near] [unclaimed]
Code size: 27472/0x6b50 (60% of load module)
Data size: 17798/0x4586 (39% of load module)
Routines in data segment; 215/0xd7, 43 routines
Completed code: 15463/0x3c67 (68 routines, 56% of code) - ported to high level language
Ignored code: 11673/0x2d99 (129 routines, 42% of code) - excluded from comparison
External ignored code: 5199/0x144f (53 routines, 44% of ignored) - typically library code
Internal ignored code: 6474/0x194a (76 routines, 55% of ignored) - typically assembly which can't be ported to identical code
Detached ignored code: 3215/0xc8f (28 routines, 27% of ignored) - internal routines which appear unreachable
Internal, non-detached ignored code: 3259/0xcbb (48 routines, 27% of ignored) - assembly routines in need of porting
Unclaimed code: 335/0x14f (33 blocks, 1% of code) - holes between routines not covered by map
Uncompleted code: 1/0x1 (1 routines, 0% of code) - routines not completed and not ignored
```

I'm telling it to `--hide` the unimportant items in the map, the idea here is to only show problematic areas, which are uncompleted and unclaimed areas (refer to the explanations in the listing). Based on this, my stats are not so rosy; I only have 56% of the code rewritten into C, but remember this is in relation to the entire code segment size, which contains libc and some apparent unreachable (detached) code. The crux of these stats is the hideously named "Internal, non-detached ignored", or INDI-counter as I've come to call it (just now). It tells me I have about 3kB, or 48 assembly routines to worry about. Unless some of the unreachable code (of which there also seems to be about 3kB) turns out to be actually reachable - but I'll worry about it if and when.

The single uncompleted routine taking one byte is a bug. I've no idea where it comes from, and I have no energy to track it down. So I will let it eat at me until I can't take it anymore. 

# So, now what?

With the C reconstruction work done for `START.EXE`, the work now switches gears into assembly tweaking and porting. The first order of business is to get the game runnable. I need to go over the INDI routines, replace any hardcoded offsets with data symbol references, built the executable and make it work with the rest of the game. At this stage it might actually be helpful to let `mzdiff` compare the "up-till-now-ignored" routines, to make sure my modifications do not alter the code, and that the layout stays consistent. It will probably screw with my stats, but I'll figure it out later.

At that point I will have code for a binary that's "free" - I will be able to add to it, and it should be tolerant of changes in internal layout. Then, all these assembly routines that can, will be rewritten into C to make the game more easily portable outside MS-DOS in the future. Doing so will make them completely divergent and non-comparable, so I will need to figure out some way to make sure they operate correctly, potentially with unit testing. Only then will I be free to move on to `EGAME.EXE` and do the whole thing all over again. And that doesn't even cover the fact that the source code is still obscure and will need research to fully document all the routines and data which for now have placeholder names, since I have no idea what they are doing, even though I might have transcribed them into C.

But then again, at least I have something to do for the forseeable future. Good night!