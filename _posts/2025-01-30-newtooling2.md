---
layout: post
title: New tools provide better game data insight
date: 2025-01-29
category: f15-se2
---
<small>(_This post is part of a [series]({% link category/f15-se2.html %}) on the subject of my hobby project, which is recreating the C source code for the 1989 game [F-15 Strike Eagle II]({% post_url 2022-06-05-origins %}) by reverse engineering the original binaries._)</small>

I guess you could say I am procrastinating with moving onto the next executable to reconstruct after my recent success with making `START.EXE` runnable, but I had a couple ideas for the tooling which I wanted to check out first. So here's a brief summary of what's available in [mzretools 0.9.7](https://github.com/neuviemeporte/mzretools).

I already [fixed]({% post_url 2024-12-31-newtooling %}) a bunch of bugs that would likely limit my tools' robustness when working on `EGAME.EXE`, and together with these new features, I think I'm in a good place to take on the new work. Also, changing gears once in a while to work on algorithmic stuff in a modern codebase helps me keep from burning out on the ancient assembly opcodes.

# mzdup

With the way the game is structured with the 3 main executables for the main stages of the game, I'm pretty sure there must be at least *some* code duplication between them. They are avoiding most of it by putting the common graphics/sound/input routines into [overlays]({% post_url 2023-07-12-overlays %}) and dynamically loading in the code at runtime, but these are mostly low-level operations for things like drawing a sprite or a string at a particular screen location. Meanwhile, the code for [loading the sprite data](https://github.com/neuviemeporte/f15se2-re/blob/main/src/start4.asm#L1534) and [setting up the overlays](https://github.com/neuviemeporte/f15se2-re/blob/main/src/start4.asm#L938) themselves is present out in the open in `START.EXE`, and I'm pretty sure `EGAME.EXE` will need to do pretty much the same thing. The next executable is going to be challenging due to its larger size and the kind of thing it does (3D rendering and projection math), so I'm going to milk the work that I already did for the first one as much as I can.

The task then is to find duplicate routines from `START` in `EGAME`. Obviously, I cannot just search for the binary data because the offsets encoded in the 8086 assembly instructions are going to be different, and I won't find anything longer that a couple instructions. Also, there is no guarantee that the routines even contain the exact same instructions - the code might have been tweaked between linking one executable vs the other. They might even have used a different assembler which used a different encoding for the instructions, who knows?

I am aware that this is a solved problem because of the existence of [FLIRT](https://docs.hex-rays.com/user-guide/signatures/flirt) in IDA, but for one, generating FLIRT signatures from binaries requires the paid version of IDA which I don't have, and it would require me to go into a Win XP VM which I use to run IDA. I wanted the experience to be more streamlined. Also, it seemed like an interesting challenge which I figured I could pull off, which is as good excuse as any in my book. ðŸ˜‰

The first problem is similar to what I encountered when initially implementing `mzdiff`; I needed to compare instructions between two divergent executables that I wanted to make identical, so I have some facilities implemented to strip out the offsets from parsed instructions. The instructions are also represented in an abstract way in my code, each belonging to a "class" that is more or less equivalent to an assembly mnemonic (`mov`/`cmp`/`call`). So it wasn't difficult to format the instructions of a routine into a string of abstract "signatures" which are just the optional segment override prefix, the class, and the operand types (mem/reg/immediate) [fused together](https://github.com/neuviemeporte/mzretools/commit/cf92f11137f384afdd998f65460d850fa57b0f21#diff-679ea22dfd0ffd35b16186f70f94d92c84f8db9fc28ecca2bb51573071944fceR658) to form a 32bit "character" of the string I will be searching for.

The second problem is kind of brainy. Basically, I need to calculate the [edit distance](https://en.wikipedia.org/wiki/Edit_distance) (from now on, "ED") between the two strings formed by the signatures generated from the instructions of two routines to tell me how many instructions need to be modified to make the routines identical. However, I was never good at implementing fancy algorithms from descriptions in research papers. So I ended up ["borrowing"](https://github.com/roy-ht/editdistance) the implementation from somebody else. Thanks!

Now it's just a matter of brute forcing the solution, trying to match every routine from my "known" executable against every potential entrypoint location in the "unknown" one. I have some simple heuristics to avoid calculating the ED between routines which differ too much by the instruction count as to immediately tell that the ED will not fill below the maximum difference threshold. Also, the ED routine will interrupt the calculation as soon as it determines that the threshold will not be satisfied. That's about as much as I can bother with in terms of optimization. I implemented a new tool called `mzdup` as a thin frontend for calling the appropriate analysis routine, so let's give it a spin:

# mzptr

While fixing the [multitude of bugs]({% post_url 2025-01-09-start-runs %}) that prevented `START` from working, some of them predictably turned out to be variables which I thought were straight numeric values, that actually ended up being pointers to different variables. Since the layout of the reconstruction differs from the original, the hard-baked pointers don't match after rebuilding, and stuff breaks. I found and resolved a bunch of them, but that gave me an idea of trying to do it semi-automatically. Essentially, if I knew where the variables were, I could just brute force search the raw contents of the data segment for numbers which match the offsets of known variables. Sure, I'm bound to get some false positives, but maybe also catch some pointers that flew under the radar?

The biggest challenge here was actually "knew where the variables were". I am identifying memory operands while comparing with `mzdiff`, but `mzmap` did not take note of data while walking the executable, so it was a fair bit of development effort as well as refactoring (`RoutineMap` became `CodeMap` as it doesn't only track routines anymore) to get it done. Now, the map file that `mzmap` spits out will also contain found memory operand offsets as potential variable locations. Next, it was a matter of implementing the search. I'm scanning the data segment(s) byte by byte, extracting a 16bit value at every location by swapping the little-endian bytes, and comparing it with all the offsets of all the known variables - nothing subtle. In the future, the search could be extended to the code segment for any lingering pointers that could have been put there with assembly.

Meanwhile, the new utility `mzptr` serves as a frontend for this capability. The useful feature it has is that it will sort the found references by the found count, with the idea being that variables with fewer matches are more likely to be genuine pointers. That's because a variable located at an offset which is a small or non-distinct value like `0x0800` is very likely to spawn multiple false positives at many locations, whereas a value like `0x7fc3` if more likely to be represented once, or not at all. Additionally, within the same match count, variables are sorted by the offset at which they were found, which lets me spot sequential arrays of pointers. So again, let's try it out:

# conclusion

Admittedly, the results are not groundbreaking, but this was something that I just needed to check out of curiosity. Also, I think this work will pay dividens in the future because:

1. I expect `END.EXE` (the debriefing stage which mostly just shows static images) to be more similar to `START` than `EGAME` is, so I expect to find a fair amount of duplication there,
2. I will need to find pointers in both `EGAME` and `END`, so `mzptr` will see its share of work,
3. The tools project is not only about F-15 SE2 and this could come useful to somebody working on a different project,
4. The other Microprose flight games on this engine (F-19/F-117) are likely going to contain some duplication, so being able to find matching routines is going to go a long way towards supporting them some day.